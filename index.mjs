import{writable as t,derived as e,get as s}from"svelte/store";const r=(t,e)=>{if(!Array.isArray(t))return null;for(const s of t)if("function"==typeof s)try{const t=s(e);if(null!=t)return t}catch(t){console.error("validator error",s,t)}return null};class o{constructor(e){this.validators=t(e)}setValidators(t){Array.isArray(t)&&t.length&&this.validators.set(t)}}class i extends o{constructor(s,o=[]){super(o),this.initial=s,this.value=t(this.initial),this.touched=t(!1),this.state=e([this.value,this.touched,this.validators],(([t,e,s])=>{const o=r(s,t);return{$error:o,$valid:null==o,$touched:e,$dirty:this.initial!==t}}))}setTouched(t){this.touched.set(t)}child(){return null}reset(t){void 0!==t&&(this.initial=t),this.value.set(this.initial),this.touched.set(!1)}}const l=/^([^.[]+)\.?(.*)$/;class n extends o{constructor(o,i=[]){super(i),this.controlStore=t({}),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=e(this.controlStore,((t,s)=>{const r=Object.keys(t),o=r.map((e=>t[e].value));return e(o,(t=>t.reduce(((t,e,s)=>(t[r[s]]=e,t)),{}))).subscribe(s)})),this.childStateDerived=e(this.controlStore,((t,s)=>{const r=Object.keys(t),o=r.map((e=>t[e].state));return e(o,(t=>t.reduce(((t,e,s)=>(t[r[s]]=e,t)),{}))).subscribe(s)})),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(s(this.valueDerived)))},this.state=e([this.valueDerived,this.childStateDerived,this.validators],(([t,e,s])=>{const o={};let i=!0,l=!1,n=!1;for(const t of Object.keys(e)){const s=o[t]=e[t];i=i&&s.$valid,l=l||s.$touched,n=n||s.$dirty}const u=r(s,t),c=null==u&&i;return Object.assign({$error:u,$valid:c,$touched:l,$dirty:n},o)})),this.controlStore.set(o)}iterateControls(t){const e=s(this.controlStore);Object.entries(e).forEach(t)}setValue(t){this.iterateControls((([e,s])=>{var r;const o=null!==(r=null==t?void 0:t[e])&&void 0!==r?r:null;s.value.set(o)}))}addControl(t,e){this.controlStore.update((s=>(s[t]=e,s)))}removeControl(t){this.controlStore.update((e=>(delete e[t],e)))}setTouched(t){this.iterateControls((([e,s])=>{s.setTouched(t)}))}child(t){const[e,r,o]=t.match(l)||[],i=s(this.controlStore),n=r&&i[r]||null;return n?o?n.child(o):n:null}reset(t){this.iterateControls((([e,s])=>{const r=t&&t[e]||null;s.reset(r)}))}}const u=/^\[(\d+)\]\.?(.*)$/;class c extends o{constructor(o,i=[]){super(i),this._controls=o,this.controlStore=t(this._controls),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=e(this.controlStore,((t,s)=>e(t.map((t=>t.value)),(t=>t)).subscribe(s))),this.childStateDerived=e(this.controlStore,((t,s)=>e(t.map((t=>t.state)),(t=>t)).subscribe(s))),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(s(this.valueDerived)))},this.state=e([this.valueDerived,this.childStateDerived,this.validators],(([t,e,s])=>{const o={list:[]};let i=!0;for(let t=0,s=e.length;t<s;t++){const s=e[t];o.list[t]=s,i=i&&s.$valid,o.$touched=o.$touched||s.$touched,o.$dirty=o.$dirty||s.$dirty}return o.$error=r(s,t),o.$valid=null==o.$error&&i,o}))}iterateControls(t){s(this.controlStore).forEach(t)}setValue(t){this.iterateControls(((e,s)=>{var r;const o=null!==(r=null==t?void 0:t[s])&&void 0!==r?r:null;e.value.set(o)}))}setTouched(t){this.iterateControls((e=>e.setTouched(t)))}pushControl(t){this.controlStore.update((e=>(e.push(t),e)))}addControlAt(t,e){this.controlStore.update((s=>(s.splice(t,0,e),s)))}removeControlAt(t){this.controlStore.update((e=>(e.splice(t,1),e)))}removeControl(t){this.controlStore.update((e=>e.filter((e=>e!==t))))}slice(t,e){this.controlStore.update((s=>s.slice(t,e)))}child(t){const[e,r,o]=t.match(u)||[],i=s(this.controlStore),l=null!=r&&i[+r]||null;return l?o?l.child(o):l:null}reset(t){this.iterateControls(((e,s)=>{const r=t&&t[s]||null;e.reset(r)}))}}const a=(t,e)=>{if(!(e instanceof i))throw new Error("must be used with a Control class");const r=t.classList,o=e.state.subscribe((t=>{t.$error?(r.add("invalid"),r.remove("valid")):(r.add("valid"),r.remove("invalid")),t.$dirty?(r.add("dirty"),r.remove("pristine")):(r.add("pristine"),r.remove("dirty")),t.$touched?r.add("touched"):r.remove("touched")})),l=["blur","focusout"],n=()=>{s(e.state).$touched||e.setTouched(!0)};return l.forEach((e=>t.addEventListener(e,n))),{destroy(){l.forEach((e=>t.removeEventListener(e,n))),o()}}},h=t=>null==t||""==`${t}`,d=t=>""!==(null!=t&&!1!==t?`${t}`.trim():"")?null:{required:!0},v=/^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,$=t=>h(t)||v.test(t)?null:{email:!0},b=t=>e=>h(e)||null==t||`${e}`.trim().length>=t?null:{minLength:t},m=t=>e=>h(e)||null==t||`${e}`.trim().length<=t?null:{maxLength:t},p=t=>h(t)||!isNaN(+t)?null:{number:!0},S=/^\d*\.?\d+$/,f=t=>h(t)||!isNaN(+t)&&S.test(`${t}`)?null:{decimal:!0},y=/^\d+$/,C=t=>h(t)||!isNaN(+t)&&y.test(`${t}`)?null:{integer:!0},D=t=>e=>h(e)||!isNaN(+e)&&(null==t||e>=t)?null:{min:t},N=t=>e=>h(e)||!isNaN(+e)&&(null==t||e<=t)?null:{max:t},A=t=>e=>h(e)||null==t||t.test(e)?null:{pattern:`${t}`};export{i as Control,c as ControlArray,o as ControlBase,n as ControlGroup,a as controlClasses,f as decimal,$ as email,C as integer,N as max,m as maxLength,D as min,b as minLength,p as number,A as pattern,d as required};
//# sourceMappingURL=index.mjs.map
