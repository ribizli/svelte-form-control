{"version":3,"file":"index.mjs","sources":["../src/utils.ts","../src/control.ts","../src/use-actions.ts","../src/validators.ts"],"sourcesContent":["import { ValidatorFn } from \"./validators\";\n\nexport const chainValidators: (validators: ValidatorFn[]) => ValidatorFn = validators => {\n\tif (!Array.isArray(validators)) return (value: any) => null;\n\treturn fieldValue => {\n\t\tfor (const validator of validators) {\n\t\t\tconst result = validator(fieldValue);\n\t\t\tif (result) return result;\n    }\n    return null;\n\t}\n}\n\nexport const validateIterated = <T>(validators: ValidatorFn<T>[], fieldValue: T) => {\n\tif (!Array.isArray(validators)) return null;\n\t\tfor (const validator of validators) {\n\t\t\tif (typeof validator === 'function') {\n        try {\n\t\t\t\t\tconst result = validator(fieldValue);\n\t\t\t\t\tif (result != null) return result;\n        } catch (e) {\n          console.error(`validator error`, validator, e);\n        }\n      }\n    }\n    return null;\n}\n","import { derived, get, Readable, writable, Writable } from 'svelte/store';\nimport { validateIterated } from './utils';\nimport { ValidationError, ValidatorFn } from './validators';\n\ntype GroupValue<T> = { [K in keyof T]: T[K] };\n\ntype ControlTypes = string | number | boolean;\n\nexport interface $ControlState {\n  $error: ValidationError | null;\n\n  $valid: boolean;\n\n  $touched: boolean;\n\n  $dirty: boolean;\n}\n\ntype ControlState<T = any> = T extends (infer K)[] ? $ControlState & { list: Array<ControlState<K>> }\n  : T extends ControlTypes ? $ControlState\n  : T extends GroupValue<T> ? { [K in keyof T]: ControlState<T[K]> & $ControlState }\n  : $ControlState;\n\nexport abstract class ControlBase<T = any> {\n\n  protected validators: Writable<ValidatorFn<T>[]>;\n\n  constructor(validators: ValidatorFn<T>[]) {\n    this.validators = writable(validators);\n  }\n\n  abstract value: Writable<T>;\n\n  abstract state: Readable<ControlState<T>>;\n\n  abstract child(path: string): ControlBase;\n\n  abstract reset(value?: T): void;\n\n  abstract setTouched(touched: boolean): void;\n\n  setValidators(validators: ValidatorFn<T>[]) {\n    if (!(Array.isArray(validators) && validators.length)) return;\n    this.validators.set(validators);\n  }\n\n}\n\nexport class Control<T = ControlTypes> extends ControlBase<T> {\n\n  value = writable<T>(this.initial);\n\n  private touched = writable(false);\n\n  state = derived([this.value, this.touched, this.validators], ([value, $touched, validators]) => {\n    const $error = validateIterated(validators, value);\n    const $valid = $error == null;\n    const $dirty = this.initial !== value;\n    return { $error, $valid, $touched, $dirty } as ControlState<T>;\n  });\n\n  constructor(\n    private initial: T,\n    validators: ValidatorFn<T>[] = [],\n  ) {\n    super(validators);\n  }\n\n  setTouched(touched: boolean) {\n    this.touched.set(touched);\n  }\n\n  child() {\n    return null!;\n  }\n\n  reset(value?: T) {\n    if (value !== undefined) this.initial = value;\n    this.value.set(this.initial);\n    this.touched.set(false);\n  };\n\n}\n\ntype Controls<T> = { [K in keyof T]: ControlBase<T[K]> };\ntype ControlsState<T> = { [K in keyof T]: $ControlState };\nconst objectPath = /^([^.[]+)\\.?(.*)$/;\n\nexport class ControlGroup<T> extends ControlBase<T> {\n\n  private controlStore = writable<Controls<T>>({} as any);\n\n  controls: Readable<Controls<T>> = { subscribe: this.controlStore.subscribe };\n\n  private valueDerived = derived(this.controlStore, (controls: Controls<T>, set: (value: T) => void) => {\n    const keys = Object.keys(controls) as Array<keyof T>;\n    const controlValues = keys.map(key => controls[key].value);\n    const derivedValues = derived(controlValues as any,\n      values => (<any[]>values).reduce((acc, value, index) => (acc[keys[index]] = value, acc), {}) as T);\n    return derivedValues.subscribe(set);\n  });\n\n  private childStateDerived = derived(this.controlStore,\n    (controls: Controls<T>, set: (value: ControlsState<T>) => void) => {\n      const keys = Object.keys(controls) as Array<keyof T>;\n      const controlStates = keys.map(key => controls[key].state);\n      const derivedStates = derived(controlStates as any,\n        states => (<any[]>states).reduce((acc, state, index) => (acc[keys[index]] = state, acc), {}) as ControlsState<T>);\n      return derivedStates.subscribe(set);\n    });\n\n  value: Writable<T> = {\n    subscribe: this.valueDerived.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueDerived))),\n  };\n\n  state = derived(\n    [this.valueDerived, this.childStateDerived, this.validators],\n    ([value, childState, validators]) => {\n      const children: Record<string, $ControlState> = {};\n      let childrenValid = true;\n      let $touched = false;\n      let $dirty = false;\n      for (const key of Object.keys(childState)) {\n        const state = children[key] = (childState as any)[key] as $ControlState;\n        childrenValid = childrenValid && state.$valid;\n        $touched = $touched || state.$touched;\n        $dirty = $dirty || state.$dirty;\n      }\n      const $error = validateIterated(validators, value);\n      const $valid = $error == null && childrenValid;\n      return { $error, $valid, $touched, $dirty, ...children } as ControlState<T>;\n    });\n\n  constructor(\n    controls: Controls<T>,\n    validators: ValidatorFn<T>[] = [],\n  ) {\n    super(validators);\n    this.controlStore.set(controls);\n  }\n\n  private iterateControls<K extends keyof T>(callback: (args: [K, ControlBase<T[K]>]) => void) {\n    const controls = get(this.controlStore);\n    (<[K, ControlBase<T[K]>][]>Object.entries(controls)).forEach(callback);\n  }\n\n  private setValue(value: T) {\n    this.iterateControls(([key, control]) => {\n      const controlValue = value?.[key] ?? null;\n      control.value.set(controlValue!);\n    });\n  }\n\n  addControl(key: string, control: ControlBase) {\n    this.controlStore.update(controls => ((<any>controls)[key] = control, controls));\n  }\n\n  removeControl(key: string) {\n    this.controlStore.update(controls => (delete (<any>controls)[key], controls));\n  }\n\n  setTouched(touched: boolean) {\n    this.iterateControls(([_, control]) => {\n      control.setTouched(touched);\n    });\n  }\n\n  child(path: string) {\n    const [_, name, rest] = path.match(objectPath) || [];\n    const controls = get(this.controlStore);\n    const control = name && (controls as any)[name] as ControlBase || null;\n    if (!control) return null!;\n    return rest ? control.child(rest) : control;\n  }\n\n  reset(value?: T) {\n    this.iterateControls(([key, control]) => {\n      const controlValue = value && value[key] || null;\n      control.reset(controlValue!);\n    });\n  };\n\n}\n\nconst arrayPath = /^\\[(\\d+)\\]\\.?(.*)$/;\n\nexport class ControlArray<T> extends ControlBase<T[]> {\n\n  private controlStore = writable(this._controls);\n\n  controls: Readable<ControlBase<T>[]> = { subscribe: this.controlStore.subscribe };\n\n  private valueDerived = derived(this.controlStore, (controls: ControlBase<T>[], set: (value: T[]) => void) => {\n    const derivedValues = derived(\n      controls.map(control => control.value) as any,\n      values => values as T[]);\n    return derivedValues.subscribe(set);\n  });\n\n  private childStateDerived = derived(this.controlStore,\n    (controls: ControlBase<T>[], set: (value: $ControlState[]) => void) => {\n      const derivedStates = derived(\n        controls.map(control => control.state) as any,\n        values => values as $ControlState[]);\n      return derivedStates.subscribe(set);\n    });\n\n  value: Writable<T[]> = {\n    subscribe: this.valueDerived.subscribe,\n    set: value => this.setValue(value),\n    update: updater => this.setValue(updater(get(this.valueDerived))),\n  };\n\n  state = derived(\n    [this.valueDerived, this.childStateDerived, this.validators],\n    ([value, childState, validators]) => {\n      const arrayState = {} as $ControlState & { list: $ControlState[] };\n      arrayState.list = [];\n      let childrenValid = true;\n      for (let i = 0, len = childState.length; i < len; i++) {\n        const state = childState[i];\n        arrayState.list[i] = state;\n        childrenValid = childrenValid && state.$valid;\n        arrayState.$touched = arrayState.$touched || state.$touched;\n        arrayState.$dirty = arrayState.$dirty || state.$dirty;\n      }\n      arrayState.$error = validateIterated(validators, value);\n      arrayState.$valid = arrayState.$error == null && childrenValid;\n\n      return arrayState as ControlState<T[]>;\n    });\n\n  constructor(\n    private readonly _controls: ControlBase<T>[],\n    validators: ValidatorFn<T[]>[] = [],\n  ) {\n    super(validators);\n  }\n\n  private iterateControls(callback: (control: ControlBase<T>, index: number) => void) {\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    controls.forEach(callback);\n  }\n\n  private setValue(value: T[]) {\n    this.iterateControls((control, index) => {\n      const controlValue = value?.[index] ?? null;\n      control.value.set(controlValue!);\n    });\n  }\n\n  setTouched(touched: boolean) {\n    this.iterateControls(control => control.setTouched(touched));\n  }\n\n  pushControl(control: ControlBase<T>) {\n    this.controlStore.update(controls => (controls.push(control), controls));\n  }\n\n  addControlAt(index: number, control: ControlBase<T>) {\n    this.controlStore.update(controls => (controls.splice(index, 0, control), controls));\n  }\n\n  removeControlAt(index: number) {\n    this.controlStore.update(controls => (controls.splice(index, 1), controls));\n  }\n\n  removeControl(control: ControlBase<T>) {\n    this.controlStore.update(controls => controls.filter(c => c !== control));\n  }\n\n  slice(start?: number, end?: number) {\n    this.controlStore.update(controls => controls.slice(start, end));\n  }\n\n  child(path: string) {\n    const [_, index, rest] = path.match(arrayPath) || [];\n    const controls: ControlBase<T>[] = get(this.controlStore);\n    const control = index != null && controls[+index] || null;\n    if (!control) return null!;\n    return rest ? control.child(rest) : control;\n  }\n\n  reset(value?: T[]) {\n    this.iterateControls((control, index) => {\n      const controlValue = value && value[index] || null;\n      control.reset(controlValue!);\n    });\n  }\n\n}\n","import { get, Readable } from 'svelte/store';\nimport { $ControlState, Control, ControlBase } from \"./control\";\n\nexport const controlClasses = (el: HTMLElement, control: Control) => {\n\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\tconst classList = el.classList;\n\n\tconst stateSub = control.state.subscribe((state) => {\n\t\tif (state.$error) {\n\t\t\tclassList.add('invalid');\n\t\t\tclassList.remove('valid');\n\t\t} else {\n\t\t\tclassList.add('valid');\n\t\t\tclassList.remove('invalid');\n\t\t}\n\n\t\tif (state.$dirty) {\n\t\t\tclassList.add('dirty');\n\t\t\tclassList.remove('pristine');\n\t\t} else {\n\t\t\tclassList.add('pristine');\n\t\t\tclassList.remove('dirty');\n\t\t}\n\n\t\tif (state.$touched) {\n\t\t\tclassList.add('touched');\n\t\t} else {\n\t\t\tclassList.remove('touched');\n\t\t}\n\n\t});\n\n\tconst eventNames = ['blur', 'focusout'];\n\n\tconst unregister = () => eventNames.forEach(eventName => el.removeEventListener(eventName, touchedFn));\n\n\tconst touchedFn = () => {\n\t\tif ((<$ControlState>get(control.state)).$touched) return;\n\t\tcontrol.setTouched(true);\n\t}\n\n\teventNames.forEach(eventName => el.addEventListener(eventName, touchedFn));\n\n\treturn {\n\t\tdestroy() {\n\t\t\tunregister();\n\t\t\tstateSub();\n\t\t}\n\t}\n};\n","export interface ValidationError<D = any> {\n\t[name: string]: D;\n}\n\nexport type ValidatorFn<T = any, D = any> = (fieldValue: T) => ValidationError<D> | null;\n\ntype ValidatorFactory<C = unknown, T = any, D = any> = (config: C) => ValidatorFn<T, D>;\n\nconst empty = (value: any) => value == null || `${value}` === '';\n\nexport const required: ValidatorFn<string | number | boolean, boolean> = value => {\n\tlet stringValue = value != null && value !== false ? `${value}`.trim() : '';\n\treturn stringValue !== '' ? null : { required: true };\n};\n\nconst emailFormat = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\nexport const email: ValidatorFn<string, boolean> = email => {\n\tconst valid = empty(email) || emailFormat.test(email);\n\treturn valid ? null : { email: true };\n};\n\nexport const minLength: ValidatorFactory<number, string, number> = min => value => {\n\tconst valid = empty(value) || min == null || `${value}`.trim().length >= min;\n\treturn valid ? null : { minLength: min };\n};\n\nexport const maxLength: ValidatorFactory<number, string, number> = max => value => {\n\tconst valid = empty(value) || max == null || `${value}`.trim().length <= max;\n\treturn valid ? null : { maxLength: max };\n};\n\nexport const number: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number);\n\treturn valid ? null : { number: true };\n};\n\nconst decimalFormat = /^\\d*\\.?\\d+$/;\nexport const decimal: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number) && decimalFormat.test(`${number}`);\n\treturn valid ? null : { decimal: true };\n};\n\nconst intFormat = /^\\d+$/;\nexport const integer: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number) && intFormat.test(`${number}`);\n\treturn valid ? null : { integer: true };\n};\n\n\nexport const min: ValidatorFactory<number, string | number, number> = min => number => {\n\tconst valid = empty(number) || !isNaN(+number) && (min == null || number >= min);\n\treturn valid ? null : { min };\n};\n\nexport const max: ValidatorFactory<number, string | number, number> = max => number => {\n\tconst valid = empty(number) || !isNaN(+number) && (max == null || number <= max);\n\treturn valid ? null : { max };\n};\n\nexport const pattern: ValidatorFactory<RegExp, string, string> = re => text => {\n\tconst valid = empty(text) || (re == null || re.test(text));\n\treturn valid ? null : { pattern: `${re}`};\n};\n"],"names":["validateIterated","validators","fieldValue","Array","isArray","validator","result","e","console","error","ControlBase","[object Object]","this","writable","length","set","Control","initial","super","derived","value","touched","$touched","$error","$valid","$dirty","undefined","objectPath","ControlGroup","controls","subscribe","controlStore","keys","Object","controlValues","map","key","values","reduce","acc","index","controlStates","state","states","valueDerived","setValue","update","updater","get","childStateDerived","childState","children","childrenValid","callback","entries","forEach","iterateControls","control","controlValue","_","setTouched","path","name","rest","match","child","reset","arrayPath","ControlArray","_controls","arrayState","list","i","len","push","splice","filter","c","start","end","slice","controlClasses","el","Error","classList","stateSub","add","remove","eventNames","touchedFn","eventName","addEventListener","removeEventListener","empty","required","trim","emailFormat","email","test","minLength","min","maxLength","max","number","isNaN","decimalFormat","decimal","intFormat","integer","pattern","re","text"],"mappings":"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"}